# Git 开发 Prompts

## 分支管理

### 功能分支工作流

```text
请按照功能分支工作流协助我进行 Git 开发：

项目背景：[在此描述项目背景]
功能需求：[在此描述功能需求]

要求：
1. 创建功能分支进行开发
2. 遵循规范的提交信息格式
3. 完成功能开发后合并回主分支
4. 提供完整的 Git 命令操作步骤
```

### Git Flow 工作流

```text
请按照 Git Flow 工作流协助我进行团队协作开发：

项目背景：[在此描述项目背景]
功能需求：[在此描述功能需求]

要求：
1. 正确使用 feature、develop、release、hotfix 分支
2. 遵循分支命名规范
3. 遵循合并策略
4. 提供完整的 Git 命令操作步骤
```

### Trunk-Based Development 工作流

```text
代码库： [描述]
发布频率： [高 / 中 / 低]

请：
1. 定义短生命周期分支策略
2. Feature Flag 使用准则
3. 集成频率与自动化校验建议
4. Merge vs Rebase 选择原则
```

## 创建新分支

### 切换到新分支进行开发

```text
我需要基于当前分支创建并切换到一个新分支进行功能开发：

当前分支：[当前分支名称，如 main/master]
新分支名称：[新分支名称，如 feature/user-auth]
功能描述：[在此描述新功能或任务]

要求：
1. 提供创建并切换到新分支的 Git 命令
2. 遵循分支命名规范（如 feature/、bugfix/、hotfix/ 等前缀）
3. 说明如何确认已成功切换到新分支
4. 提供后续开发流程建议
```

## 提交信息规范

### 标准化提交信息

```text
请帮我编写符合 Conventional Commits 规范的提交信息：

变更内容：
[在此描述变更内容]

要求：
1. 使用正确的提交类型（feat、fix、chore、docs 等）
2. 清晰简洁的提交标题
3. 必要时添加详细的提交描述
4. 引用相关 issue 编号（如适用）
```

### 提交拆分建议

```text
改动描述： [混合功能/修复/重构]
当前状态： 已暂存 or 未暂存

请：
1. 建议的逻辑提交拆分边界
2. 每个提交的标题草案
3. 交互式暂存命令示例
4. 避免“大杂烩”提交的原则
```

### 提交信息自动生成模板

```text
改动类型： [feat/fix/refactor/perf/docs/chore]
范围： [模块名]
描述： [一句话]
细节： [可选多行]
关联： [Issue/PR]

请输出符合 Conventional Commits 的最终提交信息。
```

## 版本管理

### 语义化版本控制

```text
请协助我为项目进行语义化版本发布：

当前版本：[当前版本号]
变更类型：[major/minor/patch]
变更内容：[详细描述变更内容]

要求：
1. 根据变更内容确定版本号递增方式
2. 创建版本标签
3. 编写更新日志
4. 提供完整的 Git 操作命令
```

### 变更记录

```text
请协助我为新版本编写变更记录（CHANGELOG）：

当前版本：[当前版本号]
新版本：[新版本号]
变更内容：
- [功能1]
- [功能2]
- [修复1]
- [其他变更]

要求：
1. 遵循 CHANGELOG 格式规范
2. 按类型分类变更内容（新增功能、修复、破坏性变更等）
3. 包含版本号和发布日期
4. 提供更新日志条目示例
```

### 版本发布

```text
请协助我发布新版本并为项目打标签：

当前版本：[当前版本号]
新版本：[新版本号，如 v1.2.0]
变更内容：[简要描述主要变更]

要求：
1. 提供版本发布的完整流程
2. 创建带有注释的标签
3. 推送标签到远程仓库
4. 提供所有必要的 Git 命令
5. 版本发布检查清单
```

## 代码审查

### 合并请求审查

```text
请以资深开发者的身份帮我审查以下合并请求：

功能描述：[功能描述]
变更文件：[变更文件列表]

审查要点：
1. 代码质量和最佳实践
2. 功能实现是否正确完整
3. 是否存在潜在 bug 或性能问题
4. 代码风格和可读性
5. 测试覆盖情况
6. 提供具体的修改建议
```

### 提交历史质量审查

```text
分支： [分支名]
范围： 最近 [N] 个提交

请：
1. 检查是否存在无意义提交（如 wip / fix typo 连续）
2. 标识可 squash 的提交组
3. 给出优化 commit 历史的 rebase -i 操作建议
4. 输出改进后理想提交列表
```

## 冲突解决

### 合并冲突处理

```text
我在合并分支时遇到了冲突，请协助我解决：

冲突文件：[冲突文件路径]
冲突内容：[冲突详细信息]

要求：
1. 分析冲突产生的原因
2. 提供解决冲突的建议方案
3. 给出完整的 Git 操作命令
```

### Rebase 冲突最优实践

```text
当前操作： git rebase [目标]
冲突文件： [列表]

请：
1. 指出是否应改为 merge 的判断依据
2. 给出逐步解决冲突策略（含保留/修改原则）
3. 常见陷阱（历史重写影响 / 强推风险）
4. 后续验证步骤（测试/编译/比对 diff）
```

## 标签和发布

### 版本标签管理

```text
请协助我管理项目的版本标签：

项目状态：[项目当前状态]
目标版本：[目标版本号]

要求：
1. 创建带有注释的标签
2. 推送标签到远程仓库
3. 版本发布检查清单
4. 提供完整的 Git 命令操作步骤
```

### 轻量标签 vs 注释标签选择

```text
用途： [临时标记 / 发布里程碑 / 部署回滚点]

请：
1. 对比 lightweight tag 与 annotated tag 差异
2. 推荐使用场景
3. 签名标签 (signed tag) 使用建议
4. 推送与清理策略
```

## 历史与排错

### 二分查找（git bisect）定位回归

```text
问题表现： [描述]
已知良好版本： [hash]
已知坏版本： [hash]

请：
1. 给出 git bisect 操作步骤
2. 自动化测试脚本集成示例
3. 结果判定策略（不确定/不稳定处理）
4. 回归根因记录模板
```

### 敏感信息清理

```text
泄漏内容： [token/password/密钥文件]
引入提交： [hash]

请：
1. 判断是否需要历史重写（范围/风险）
2. git filter-repo 或 BFG 使用示例
3. 失效与替换策略（吊销 / 轮换）
4. 事后审计与预防措施
```

### 大文件与仓库瘦身

```text
仓库大小： [数值]
问题文件： [列出]

请：
1. 识别大文件与高重复对象方法
2. 清理历史的方案（git filter-repo）
3. Git LFS 使用场景建议
4. 清理后验证与团队同步步骤
```

## Monorepo 管理

### 子包版本与发布策略

```text
工具： [pnpm workspaces / Lerna / Nx / Turborepo]
包数量： [数]

请：
1. 独立版本 vs 锁步版本对比
2. 变更影响检测机制（diff / graph 分析）
3. 发布流水线拆分设计
4. 回滚与 Tag 命名规范
```

### 依赖关系可视化与治理

```text
语言生态： [Node / Go / Java]

请：
1. 构建依赖图方法
2. 检测循环依赖与过深链路策略
3. 内部公共模块抽取建议
4. 去重与版本统一策略
```

## 自动化与钩子

### Git Hooks 策略

```text
目标： [提高质量 / 减少低级错误]

请：
1. 钩子点选择（pre-commit / commit-msg / pre-push 等）
2. 配套工具（lint-staged / husky / lefthook）
3. 性能与快速跳过机制
4. 团队共享与版本管理建议
```

### 提交规范自动校验

```text
现状： [未校验 / 部分校验]
工具： [commitlint / custom script]

请：
1. 规则集定义（type/scope/长度）
2. 配置示例
3. 与 CI 集成方式
4. 失败提示与本地修复指引
```

## 示例请求模板

```text
当我描述：
场景：<发布 / 回滚 / 定位问题 / 重构>
目标：<清晰历史 / 快速定位 / 降低风险>
约束：<时间 / 合规 / 团队协作模式>
输出：请按（现状与痛点 -> 目标定义 -> 推荐命令与步骤 -> 风险与缓解 -> 验收标准）结构生成
```